# PageRankBenchmark
Stand for PageRank algorithm benchmark

# Минимальный пример

Цель примера --- показать, как в рамках GraphBLAS можно работать со сложными атрибутами вершин и рёбер графа.

В качестве примера возьмём следующую задачу.
Пусть есть граф с двумя типами вершин: пользователи и карты.
Также есть два типа ориентированных рёбер:
* "Перевод": соединяет две карты (откуда и куда перевод)
* "Владеет": соединяет пользователя и карту (от владельца карты к карте)

Каждый тип вершины имеет свой набор атрибутов.
* "Пользователь": пол, возраст
* "Карта": тип, лимит средств

Пусть будут следующие типы карт: МИР, VISA, MASTERCARD.

Каждый тип рёбер также имеет свой набор атрибутов.
* "Перевод": общая сумма, "количество транзакций"
* "Владеет": не имеет атрибутов

Для примера возьмём следующий граф.
![Пример графа](./Figures/Graph.svg)
У каждой вершины есть уникальный идентификатор, синие рёбра отображают переводы, красные --- отношение владения, розовые вершины --- пользователи, синие --- карты.

Хотим выбрать по некоторому критерию пользователей и их карты, а затем для анализа переводов хотим посчитать PageRank на подграфе, заданном переводами между отобранными картами.
Выбрать хотим все карты системы "МИР", которыми владеют пользователи мужского пола старше заданного года рождения. Покажем, как это можно сделать, используя матрично-векторные операции, в частности [GraphBLAS](https://github.com/GraphBLAS).
Полный код разбираемого примера мрожно увидеть в файле [!!!!](!!!!).

GraphBLAS позволяет в качестве атрибутов использовать пользовательские типы (фиксированных размеров), потому объявим необходимый нам набор типов.
```c
// Тип карты
typedef enum
{
    VISA,
    MIR,
    MASTERCARD,
} System;

// Пол
typedef enum
{
    MALE,
    FEMALE,
} Gender;

// Данные о пользователе
typedef struct
{
    Gender gender;
    uint8_t age;
} User;

// Данные о карте
typedef struct
{
    System system;
    double limit;
} Card;

// Данные о переводах
typedef struct
{
    double sum;
    uint32_t count;
} EdgeTX;
```

Граф представлен как набор матриц и векторов: по одной матрице на каждый тип рёбер и по одному вектору на каждый тип вершин.
Считаем при этом, что все вершины, вне зависимости от типа, занумерованы с 0 подряд (id вершин на рисунке).
Таким образом, нам понядобятся две матрицы!!! 

$$
\texttt{TX-Edges}=
\begin{pmatrix}
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & \\{23412; 6\\} & . & . & \\{13214.1; 5\\} & . & \\{99999.1; 5\\} & . \\
. & . & . & . & \\{13214.1; 5\\} & . & \\{81312; 7\\} & . & \\{92223; 9\\} & . & \\{19999.1; 6\\} & . \\
. & . & . & . & . & . & . & . & . & . & . & \\{8999.1; 7\\} \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & \\{16325.99; 5\\} & . & . & . & . & . & . & \\{49999.1; 12\\} \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & \\{79999.1; 15\\} & \\{69999.1; 16\\} & . & . & . & . & . & . \\
. & . & . & . & . & . & \\{59999.1; 12\\} & . & \\{999999.1; 9\\} & . & . & . \\
\end{pmatrix}
$$

$$
\texttt{Owns-Edges}=
\begin{pmatrix}
. & . & . & . & . & . & . & 1 & . & . & . & . \\
. & . & . & . & . & . & 1 & 1 & . & . & . & . \\
. & . & . & . & . & 1 & . & . & . & . & . & . \\
. & . & . & . & 1 & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & 1 & 1 \\
. & . & . & . & . & . & . & . & . & . & . & . \\
. & . & . & . & . & . & . & . & . & . & . & . \\
\end{pmatrix}
$$


Первым делов фильтруем пользователей. Select. Пример кода, полукольцо и т.д.

Далее, создаём диагональную матрицу из отобранных вершин и фильтруем рёбра через умножение полученной матрицы на матрицу, хранящую соответствующий тип рёбер.

Пример кода.

Далее редукция полученной матрицы, чтобы получить карты и снова диагональная матрица и умножение, чтобы получить переводы только между нужными нам картами.

Пример кода.

Конструируем матрицу, по которой будем считать PageRank. 
В качестве исходного веса ребра берём 1 - (средняя сумма перевода).
Для построения распределения будем использовать идею функции Softmax, которая задаётся следующим образом.

$$
{\displaystyle \sigma (\overrightarrow{z})_{i}={\frac {e^{z_{i}}}{\displaystyle \sum _{k\mathop {=} 1}^{K}e^{z_{k}}}}}
$$

В нашем случае подобная функция должна быть применена к каждой строке матрицы, задающей переводы. При этом должна быть задана некая функция $f$, получающая вес ребра по его атрибутам.
То есть итоговая формула выглядит следующим образом.

$$
{\displaystyle \sigma (\overrightarrow{z})_{i}={\frac {e^{f(z_{i})}}{\displaystyle \sum _{k\mathop {=} 1}^{K}e^{f(z_{k})}}}}
$$

Вычислять будем следующим образом. Сперва выполним редукцию по колонкам. Таким образом получим знаменатель дроби.
После этого тензорно умножим полученный вектор на вектор из единиц, использую исходную матрицу в качестве маски. Таким образом получим матрицу, в которой знаменатель стоит на необходимых местах. После чего поэлементно поделим две матрицы.

Пример кода.

Запускаем PageRank.

Пример кода.
