# PageRankBenchmark
Stand for PageRank algorithm benchmark

# Минимальный пример

Цель примера --- показать, как в рамках GraphBLAS можно работать со сложными атрибутами вершин и рёбер графа.

В качестве примера возьмём следующую задачу.
Пусть есть граф с двумя типами вершин: пользователи и карты.
Три типа ориентированных рёбер:
* "Перевод": соединяет две карты (откуда и куда перевод)
* "Звонок": соединяет двух пользователей (кто кому звонил)
* "Владеет": соединяет пользователя и карту (от владельца карты к карте)

Каждый тип вершины имеет свой набор атрибутов.
* "Пользователь": пол, ФИО, год рождения
* "Карта": тип, год выпуска

Каждый тип рёбер также имеет свой набор атрибутов.
* "Перевод": общая сумма, "количество транзакций"
* "Звонок": суммарная продолжительность в секундах
* "Владеет": не имеет атрибутов

Хотим выбрать по некоторому критерию пользователей  их карты и для анализа переводов хотим посчитать PageRank на подграфе, заданном переводами между отобранными картами.
Выбрать хотим все карты системы "МИР", которыми владеют пользователи мужского пола старше заданного года рождения.

Картинка графа.

Атрибуты --- структуры.

Граф представлен как набор матриц и векторов. По одной матрице на каждый тип рёбер и по одному вектору на каждый тип вершин.
Считаем при этом, что все вершины, вне зависимости от типа, занумерованы с 0 подряд.

Картинка с тем, как хранится наш граф.

Первым делов фильтруем пользователей. Select. Пример кода, полукольцо и т.д.

Далее, создаём диагональную матрицу из отобранных вершин и фильтруем рёбра через умножение полученной матрицы на матрицу, хранящую соответствующий тип рёбер.

Пример кода.

Далее редукция полученной матрицы, чтобы получить карты и снова диагональная матрица и умножение, чтобы получить переводы только между нужными нам картами.

Пример кода.

Конструируем матрицу, по которой будем считать PageRank. 
В качестве исходного веса ребра берём 1 - (средняя сумма перевода).
Для построения распределения будем использовать идею функции Softmax, которая задаётся следующим образом.

$$
{\displaystyle \sigma (\overrightarrow{z})_{i}={\frac {e^{z_{i}}}{\displaystyle \sum _{k\mathop {=} 1}^{K}e^{z_{k}}}}}
$$

В нашем случае подобная функция должна быть применена к каждой строке матрицы, задающей переводы. При этом должна быть задана некая функция $f$, получающая вес ребра по его атрибутам.
То есть итоговая формула выглядит следующим образом.

$$
{\displaystyle \sigma (\overrightarrow{z})_{i}={\frac {e^{f(z_{i})}}{\displaystyle \sum _{k\mathop {=} 1}^{K}e^{f(z_{k})}}}}
$$

Вычислять будем следующим образом. Сперва выполним редукцию по колонкам. Таким образом получим знаменатель дроби.
После этого тензорно умножим полученный вектор на вектор из единиц, использую исходную матрицу в качестве маски. Таким образом получим матрицу, в которой знаменатель стоит на необходимых местах. После чего поэлементно поделим две матрицы.

Пример кода.

Запускаем PageRank.

Пример кода.
